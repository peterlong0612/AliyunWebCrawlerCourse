Python干货（一）：27个问题，告诉你 Python 为什么如此设计？<br /><br />
                                                                        
<p><img src="https://yqfile.alicdn.com/c5fbcb02dbfae57cdb42354b2e7b402f9e6b74b5.png" alt="screenshot" title="screenshot"></p>
<ol><li>为什么使用缩进来分组语句？</li></ol>
<p>Guido van Rossum 认为使用缩进进行分组非常优雅，并且大大提高了普通 Python 程序的清晰度。大多数人在一段时间后就学会并喜欢上这个功能。</p>
<p>由于没有开始/结束括号，因此解析器感知的分组与人类读者之间不会存在分歧。偶尔 C 程序员会遇到像这样的代码片段:</p>
<p>if (x &lt;= y)<br> x++;<br> y--;<br>z++;<br>如果条件为真，则只执行 x++ 语句，但缩进会使你认为情况并非如此。即使是经验丰富的 C 程序员有时会长时间盯着它，想知道为什么即使 x &gt; y ， y 也在减少。</p>
<p>因为没有开始/结束括号，所以 Python 不太容易发生编码式冲突。在 C 中，括号可以放到许多不同的位置。如果您习惯于阅读和编写使用一种风格的代码，那么在阅读（或被要求编写）另一种风格时，您至少会感到有些不安。</p>
<p>许多编码风格将开始/结束括号单独放在一行上。这使得程序相当长，浪费了宝贵的屏幕空间，使得更难以对程序进行全面的了解。理想情况下，函数应该适合一个屏幕（例如，20--30 行）。20 行 Python 可以完成比 20 行 C 更多的工作。这不仅仅是由于缺少开始/结束括号 -- 缺少声明和高级数据类型也是其中的原因 -- 但缩进基于语法肯定有帮助。</p>
<ol><li>为什么简单的算术运算得到奇怪的结果？</li></ol>
<p>请看下一个问题。</p>
<ol><li>为什么浮点计算不准确？</li></ol>
<p>用户经常对这样的结果感到惊讶:</p>
<blockquote><blockquote><blockquote><p>1.2 - 1.0</p></blockquote></blockquote></blockquote>
<p>0.19999999999999996<br>并且认为这是 Python 中的一个 bug。其实不是这样。这与 Python 关系不大，而与底层平台如何处理浮点数字关系更大。</p>
<p>CPython 中的 float 类型使用 C 语言的 double 类型进行存储。float对象的值是以固定的精度（通常为 53 位）存储的二进制浮点数，由于 Python 使用 C 操作，而后者依赖于处理器中的硬件实现来执行浮点运算。这意味着就浮点运算而言，Python 的行为类似于许多流行的语言，包括 C 和 Java。</p>
<p>许多可以轻松地用十进制表示的数字不能用二进制浮点表示。例如，在输入以下语句后:</p>
<blockquote><blockquote><blockquote><p>x = 1.2</p></blockquote></blockquote></blockquote>
<p>为 x 存储的值是与十进制的值 1.2 (非常接近) 的近似值，但不完全等于它。在典型的机器上，实际存储的值是：</p>
<p>1.0011001100110011001100110011001100110011001100110011 (binary)<br>它对应于十进制数值:</p>
<p>1.1999999999999999555910790149937383830547332763671875 (decimal)<br>典型的 53 位精度为 Python 浮点数提供了 15-16 位小数的精度。</p>
<p>要获得更完整的解释，请参阅 Python 教程中的 浮点算术 一章。</p>
<ol><li>为什么 Python 字符串是不可变的？</li></ol>
<p>有几个优点。</p>
<p>一个是性能：知道字符串是不可变的，意味着我们可以在创建时为它分配空间，并且存储需求是固定不变的。这也是元组和列表之间区别的原因之一。</p>
<p>另一个优点是，Python 中的字符串被视为与数字一样“基本”。任何动作都不会将值 8 更改为其他值，在 Python 中，任何动作都不会将字符串 "8" 更改为其他值。</p>
<ol><li>为什么必须在方法定义和调用中显式使用“self”？</li></ol>
<p>这个想法借鉴了 Modula-3 语言。出于多种原因它被证明是非常有用的。</p>
<p>首先，更明显的显示出，使用的是方法或实例属性而不是局部变量。阅读 self.x或 self.meth() 可以清楚地表明，即使您不知道类的定义，也会使用实例变量或方法。在 C++ 中，可以通过缺少局部变量声明来判断（假设全局变量很少见或容易识别） —— 但是在 Python 中没有局部变量声明，所以必须查找类定义才能确定。一些 C++ 和 Java 编码标准要求实例属性具有 m_ 前缀，因此这种显式性在这些语言中仍然有用。</p>
<p>其次，这意味着如果要显式引用或从特定类调用该方法，不需要特殊语法。在 C++ 中，如果你想使用在派生类中重写基类中的方法，你必须使用 :: 运算符 -- 在 Python 中你可以编写 baseclass.methodname(self, )。这对于 __init__() 方法非常有用，特别是在派生类方法想要扩展同名的基类方法，而必须以某种方式调用基类方法时。</p>
<p>最后，它解决了变量赋值的语法问题：为了 Python 中的局部变量（根据定义！）在函数体中赋值的那些变量（并且没有明确声明为全局）赋值，就必须以某种方式告诉解释器一个赋值是为了分配一个实例变量而不是一个局部变量，它最好是通过语法实现的（出于效率原因）。C++ 通过声明来做到这一点，但是 Python 没有声明，仅仅为了这个目的而引入它们会很可惜。使用显式的 self.var 很好地解决了这个问题。类似地，对于使用实例变量，必须编写 self.var 意味着对方法内部的非限定名称的引用不必搜索实例的目录。换句话说，局部变量和实例变量存在于两个不同的命名空间中，您需要告诉 Python 使用哪个命名空间。</p>
<ol><li>为什么不能在表达式中赋值？</li></ol>
<p>许多习惯于 C 或 Perl 的人抱怨，他们想要使用 C 的这个特性：</p>
<p>while (line = readline(f)) {<br> // do something with line<br>}<br>但在 Python 中被强制写成这样:</p>
<p>while True:<br> line = f.readline()<br> if not line:<br> break<br> ... # do something with line<br>不允许在 Python 表达式中赋值的原因是这些其他语言中常见的、很难发现的错误，是由这个结构引起的：</p>
<p>if (x = 0) {<br> // error handling<br>}<br>else {<br> // code that only works for nonzero x<br>}<br>错误是一个简单的错字：x = 0 ，将 0 赋给变量 x ，而比较 x == 0 肯定是可以预期的。</p>
<p>已经有许多替代方案提案。大多数是为了少打一些字的黑客方案，但使用任意或隐含的语法或关键词，并不符合语言变更提案的简单标准：它应该直观地向尚未被介绍到这一概念的人类读者提供正确的含义。</p>
<p>一个有趣的现象是，大多数有经验的 Python 程序员都认识到 while True 的习惯用法，也不太在意是否能在表达式构造中赋值; 只有新人表达了强烈的愿望希望将其添加到语言中。</p>
<p>有一种替代的拼写方式看起来很有吸引力，但通常不如"while True"解决方案可靠：</p>
<p>line = f.readline()<br>while line:<br> ... # do something with line...<br> line = f.readline()<br>问题在于，如果你改变主意（例如你想把它改成 sys.stdin.readline() ），如何知道下一行。你必须记住改变程序中的两个地方 -- 第二次出现隐藏在循环的底部。</p>
<p>最好的方法是使用迭代器，这样能通过 for 语句来循环遍历对象。例如 file objects 支持迭代器协议，因此可以简单地写成:</p>
<p>for line in f:<br> ... # do something with line...<br>07 为什么 Python 对某些功能（例如 list.index()）使用方法来实现，而其他功能（例如 len(List)）使用函数实现？</p>
<p>正如 Guido 所说：</p>
<p>(a) 对于某些操作，前缀表示法比后缀更容易阅读 -- 前缀（和中缀！）运算在数学中有着悠久的传统，就像在视觉上帮助数学家思考问题的记法。比较一下我们将 x<em>(a+b) 这样的公式改写为 x</em>a+x*b 的容易程度，以及使用原始 OO 符号做相同事情的笨拙程度。<br>”<br>(b) 当读到写有 len(X)的代码时，就知道它要求的是某件东西的长度。这告诉我们两件事：结果是一个整数，参数是某种容器。相反，当阅读 x.len()时，必须已经知道 x 是某种实现接口的容器，或者是从具有标准 len()的类继承的容器。当没有实现映射的类有 get()或 key()方法，或者不是文件的类有 write()方法时，我们偶尔会感到困惑。—<a href="https://yq.aliyun.com/go/articleRenderRedirect?url=https%3A%2F%2Fmail.python.org%2Fpipermail%2Fpython-3000%2F2006-November%2F004643.html" target="_blank" data-url="https://mail.python.org/pipermail/python-3000/2006-November/004643.html">https://mail.python.org/pipermail/python-3000/2006-November/004643.html</a><br>”</p>
<ol><li>为什么 join()是一个字符串方法而不是列表或元组方法？</li></ol>
<p>从 Python 1.6 开始，字符串变得更像其他标准类型，当添加方法时，这些方法提供的功能与始终使用 String 模块的函数时提供的功能相同。这些新方法中的大多数已被广泛接受，但似乎让一些程序员感到不舒服的一种方法是：</p>
<p>", ".join(['1', '2', '4', '8', '16'])<br>结果如下:</p>
<p>"1, 2, 4, 8, 16"<br>反对这种用法有两个常见的论点。</p>
<p>第一条是这样的：“使用字符串文本(String Constant)的方法看起来真的很难看”，答案是也许吧，但是字符串文本只是一个固定值。如果在绑定到字符串的名称上允许使用这些方法，则没有逻辑上的理由使其在文字上不可用。</p>
<p>第二个异议通常是这样的：“我实际上是在告诉序列使用字符串常量将其成员连接在一起”。遗憾的是并非如此。出于某种原因，把 split() 作为一个字符串方法似乎要容易得多，因为在这种情况下，很容易看到:</p>
<p>"1, 2, 4, 8, 16".split(", ")<br>是对字符串文本的指令，用于返回由给定分隔符分隔的子字符串（或在默认情况下，返回任意空格）。</p>
<p>join() 是字符串方法，因为在使用该方法时，您告诉分隔符字符串去迭代一个字符串序列，并在相邻元素之间插入自身。此方法的参数可以是任何遵循序列规则的对象，包括您自己定义的任何新的类。对于字节和字节数组对象也有类似的方法。</p>
<ol><li>异常有多快？</li></ol>
<p>如果没有引发异常，则 try/except 块的效率极高。实际上捕获异常是昂贵的。在 2.0 之前的 Python 版本中，通常使用这个习惯用法:</p>
<p>try:<br> value = mydict[key]<br>except KeyError:<br> mydict[key] = getvalue(key)<br> value = mydict[key]<br>只有当你期望 dict 在任何时候都有 key 时，这才有意义。如果不是这样的话，你就是应该这样编码：</p>
<p>if key in mydict:<br> value = mydict[key]<br>else:<br> value = mydict[key] = getvalue(key)<br>对于这种特定的情况，您还可以使用 value = dict.setdefault(key, getvalue(key))，但前提是调用 getvalue()足够便宜，因为在所有情况下都会对其进行评估。</p>
<ol><li>为什么 Python 中没有 switch 或 case 语句？</li></ol>
<p>你可以通过一系列 if... elif... elif... else.轻松完成这项工作。对于 switch 语句语法已经有了一些建议，但尚未就是否以及如何进行范围测试达成共识。有关完整的详细信息和当前状态，请参阅 PEP 275 。</p>
<p>对于需要从大量可能性中进行选择的情况，可以创建一个字典，将 case 值映射到要调用的函数。例如：</p>
<p>def function_1(...):<br> ...<br>functions = {'a': function_1,<br> 'b': function_2,<br> 'c': self.method_1, ...}<br>func = functions[value]<br>func()<br>对于对象调用方法，可以通过使用 getattr() 内置检索具有特定名称的方法来进一步简化：</p>
<p>def visit_a(self, ...):<br> ...<br>...<br>def dispatch(self, value):<br> method_name = 'visit_' + str(value)<br> method = getattr(self, method_name)<br> method()<br>建议对方法名使用前缀，例如本例中的 visit_ 。如果没有这样的前缀，如果值来自不受信任的源，攻击者将能够调用对象上的任何方法。</p>
<ol><li>难道不能在解释器中模拟线程，而非得依赖特定于操作系统的线程实现吗？</li></ol>
<p>答案 1：不幸的是，解释器为每个 Python 堆栈帧推送至少一个 C 堆栈帧。此外，扩展可以随时回调 Python。因此，一个完整的线程实现需要对 C 的线程支持。</p>
<p>答案 2：幸运的是， Stackless Python 有一个完全重新设计的解释器循环，可以避免 C 堆栈。</p>
<ol><li>为什么 lambda 表达式不包含语句？</li></ol>
<p>Python 的 lambda 表达式不能包含语句，因为 Python 的语法框架不能处理嵌套在表达式内部的语句。然而，在 Python 中，这并不是一个严重的问题。与其他语言中添加功能的 lambda 表单不同，Python 的 lambdas 只是一种速记符号，如果您懒得定义函数的话。</p>
<p>函数已经是 Python 中的第一类对象，可以在本地范围内声明。因此，使用 lambda 而不是本地定义的函数的唯一优点是你不需要为函数创建一个名称 -- 这只是一个分配了函数对象(与 lambda 表达式生成的对象类型完全相同)的局部变量！</p>
<ol><li>可以将 Python 编译为机器代码，C 或其他语言吗？</li></ol>
<p>Cython 将带有可选注释的 Python 修改版本编译到 C 扩展中。Nuitka 是一个将 Python 编译成 C++ 代码的新兴编译器，旨在支持完整的 Python 语言。要编译成 Java，可以考虑 VOC 。</p>
<ol><li>Python 如何管理内存？</li></ol>
<p>Python 内存管理的细节取决于实现。Python 的标准实现 CPython 使用引用计数来检测不可访问的对象，并使用另一种机制来收集引用循环，定期执行循环检测算法来查找不可访问的循环并删除所涉及的对象。gc 模块提供了执行垃圾回收、获取调试统计信息和优化收集器参数的函数。</p>
<p>但是，其他实现(如 Jython 或 PyPy )，)可以依赖不同的机制，如完全的垃圾回收器 。如果你的 Python 代码依赖于引用计数实现的行为，则这种差异可能会导致一些微妙的移植问题。</p>
<p>在一些 Python 实现中，以下代码（在 CPython 中工作的很好）可能会耗尽文件描述符:</p>
<p>for file in very_long_list_of_files:<br> f = open(file)<br> c = f.read(1)<br>实际上，使用 CPython 的引用计数和析构函数方案， 每个新赋值的 f 都会关闭前一个文件。然而，对于传统的 GC，这些文件对象只能以不同的时间间隔（可能很长的时间间隔）被收集（和关闭）。</p>
<p>如果要编写可用于任何 python 实现的代码，则应显式关闭该文件或使用 with语句；无论内存管理方案如何，这都有效：</p>
<p>for file in very_long_list_of_files:<br> with open(file) as f:<br> c = f.read(1)<br>篇幅有限，剩下的干货集锦会在下一期为大家更新！</p>

                                                            </div>
                                